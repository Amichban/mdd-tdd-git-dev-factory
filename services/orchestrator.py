"""
Orchestrator Service

Fully automated coordination system that:
- Receives changes from UI or CLI
- Analyzes dependencies
- Detects conflicts with in-flight work
- Assigns worktrees
- Coordinates parallel development
- Manages the complete change lifecycle
"""

import json
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Optional
from dataclasses import dataclass
from enum import Enum

from .github_bridge import GitHubBridge, Issue, PullRequest, Worktree
from .dependency_graph import DependencyGraph


class ChangeType(Enum):
    """Types of changes to the ontology."""
    ADD_ENTITY = "add_entity"
    MODIFY_ENTITY = "modify_entity"
    DELETE_ENTITY = "delete_entity"
    ADD_PROPERTY = "add_property"
    MODIFY_PROPERTY = "modify_property"
    ADD_ALGORITHM = "add_algorithm"
    MODIFY_ALGORITHM = "modify_algorithm"
    ADD_WORKFLOW = "add_workflow"
    MODIFY_WORKFLOW = "modify_workflow"


class ChangeStatus(Enum):
    """Status of a change in the pipeline."""
    QUEUED = "queued"
    IN_PROGRESS = "in_progress"
    WAITING_FOR_DEPENDENCY = "waiting_for_dependency"
    NEEDS_REVIEW = "needs_review"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class Change:
    """Represents a change to be processed."""
    id: str
    type: ChangeType
    target_entity: str
    description: str
    requested_by: str
    details: dict
    status: ChangeStatus = ChangeStatus.QUEUED
    issue_number: Optional[int] = None
    pr_number: Optional[int] = None
    worktree: Optional[Worktree] = None


@dataclass
class Result:
    """Result of processing a change."""
    success: bool
    status: ChangeStatus
    message: str
    issue_url: Optional[str] = None
    pr_url: Optional[str] = None


class Orchestrator:
    """Fully automated coordination for the development platform."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.specs_path = project_root / "specs"
        self.github = GitHubBridge(project_root)
        self.dependency_graph = DependencyGraph(self.specs_path)
        self.active_changes: dict[str, Change] = {}

    # =========================================================================
    # ISSUE-FIRST WORKFLOW (Primary Entry Point)
    # =========================================================================

    def request_feature(
        self,
        title: str,
        description: str,
        user_story: str,
        acceptance_criteria: list[str],
        entity_definition: Optional[dict] = None,
        api_endpoints: Optional[list[str]] = None,
        ui_requirements: Optional[str] = None,
        requested_by: str = "agent"
    ) -> Result:
        """
        PRIMARY ENTRY POINT: Create a GitHub issue for a new feature.

        This must be called BEFORE any code is written. The issue becomes
        the source of truth for what needs to be built.

        Returns the issue number which can then be passed to implement_issue().
        """
        # Build the issue body
        body = f"""## Summary
{description}

## User Story
{user_story}

## Acceptance Criteria
"""
        for criterion in acceptance_criteria:
            body += f"- [ ] {criterion}\n"

        if entity_definition:
            body += f"""
## Entity Definition
```json
{json.dumps(entity_definition, indent=2)}
```
"""

        if api_endpoints:
            body += "\n## API Endpoints\n"
            for endpoint in api_endpoints:
                body += f"- [ ] {endpoint}\n"

        if ui_requirements:
            body += f"""
## UI Requirements
{ui_requirements}
"""

        body += f"""
## Technical Notes
- Generated by agent at {datetime.now().isoformat()}
- Requested by: {requested_by}

---
**Next Steps:**
1. Review and refine this issue
2. Once approved, run: `orchestrator.implement_issue({'{issue_number}'})`
"""

        # Determine labels
        labels = ["feature", "needs-review"]
        if entity_definition:
            labels.append("entity")

        # Create the issue
        issue = self.github.create_issue(
            title=f"[FEATURE] {title}",
            body=body,
            labels=labels
        )

        return Result(
            success=True,
            status=ChangeStatus.QUEUED,
            message=f"Issue #{issue.number} created. Review and approve before implementation.",
            issue_url=issue.url
        )

    def implement_issue(self, issue_number: int) -> Result:
        """
        Implement a feature from an existing GitHub issue.

        The issue MUST exist and contain the necessary specifications.
        This enforces the "issue first" workflow.
        """
        # Step 1: Verify issue exists
        issue = self.github.get_issue(issue_number)
        if not issue:
            return Result(
                success=False,
                status=ChangeStatus.FAILED,
                message=f"Issue #{issue_number} not found. Create an issue first."
            )

        # Step 2: Check issue is approved (not in needs-review)
        if "needs-review" in [label.lower() for label in issue.labels]:
            return Result(
                success=False,
                status=ChangeStatus.FAILED,
                message=f"Issue #{issue_number} is still in review. Remove 'needs-review' label to proceed."
            )

        # Step 3: Parse the issue to extract specs
        change = self.parse_issue_to_change(issue)
        if not change:
            return Result(
                success=False,
                status=ChangeStatus.FAILED,
                message=f"Could not parse issue #{issue_number}. Ensure it has entity definition."
            )

        change.issue_number = issue_number

        # Step 4: Proceed with implementation
        return self._implement_change(change, issue)

    def parse_issue_to_change(self, issue: Issue) -> Optional[Change]:
        """Parse a GitHub issue into a Change object."""
        import re

        # Extract entity definition from issue body
        json_match = re.search(
            r'## Entity Definition\s*```json\s*(.*?)\s*```',
            issue.body,
            re.DOTALL
        )

        if not json_match:
            return None

        try:
            entity_def = json.loads(json_match.group(1))
        except json.JSONDecodeError:
            return None

        # Determine change type
        entity_name = entity_def.get("name", "Unknown")

        return Change(
            id=f"issue-{issue.number}",
            type=ChangeType.ADD_ENTITY,
            target_entity=entity_name,
            description=issue.title.replace("[FEATURE] ", ""),
            requested_by="github-issue",
            details=entity_def,
            status=ChangeStatus.QUEUED
        )

    def _implement_change(self, change: Change, issue: Issue) -> Result:
        """Internal method to implement a change from an approved issue."""
        try:
            # Step 1: Analyze impact
            affected_entities = self.analyze_impact(change)
            risk_level = self.assess_risk(change, affected_entities)

            # Step 2: Check for conflicts
            conflicts = self.find_conflicts(change)
            if conflicts:
                return self.handle_conflicts(change, conflicts)

            # Step 3: Create branch and worktree
            branch_name = self._generate_branch_name(change, issue.number)
            worktree = self.github.create_worktree(issue.number, branch_name)
            change.worktree = worktree

            # Step 4: Apply the change to specs
            self.apply_change(change)

            # Step 5: Run generators
            self.run_generators(worktree)

            # Step 6: Run tests
            tests_passed = self.run_tests(worktree)

            # Step 7: Commit and push
            commit_message = self.generate_commit_message(change)
            self.github.commit_and_push(commit_message, worktree=worktree)

            # Step 8: Create PR
            pr = self.create_pr_for_change(change, issue, tests_passed)
            change.pr_number = pr.number

            # Step 9: Auto-merge or flag for review
            if self.should_auto_merge(change, risk_level, tests_passed):
                merged = self.github.merge_pr(pr.number)
                if merged:
                    self.github.remove_worktree(worktree)
                    change.status = ChangeStatus.COMPLETED
                    return Result(
                        success=True,
                        status=ChangeStatus.COMPLETED,
                        message=f"Change merged automatically",
                        issue_url=issue.url,
                        pr_url=pr.url
                    )

            change.status = ChangeStatus.NEEDS_REVIEW
            return Result(
                success=True,
                status=ChangeStatus.NEEDS_REVIEW,
                message=f"PR created, requires review (risk: {risk_level})",
                issue_url=issue.url,
                pr_url=pr.url
            )

        except Exception as e:
            change.status = ChangeStatus.FAILED
            return Result(
                success=False,
                status=ChangeStatus.FAILED,
                message=str(e)
            )

    def _generate_branch_name(self, change: Change, issue_number: int) -> str:
        """Generate a branch name following the convention."""
        # Determine prefix based on change type
        prefix = "feat"
        if change.type in [ChangeType.MODIFY_ENTITY, ChangeType.MODIFY_PROPERTY]:
            prefix = "fix"
        elif change.type == ChangeType.DELETE_ENTITY:
            prefix = "refactor"

        # Sanitize entity name for branch
        entity_slug = change.target_entity.lower().replace("_", "-")

        return f"{prefix}/issue-{issue_number}-{entity_slug}"

    def submit_change(self, change: Change) -> Result:
        """
        Submit a change for processing.

        This is the main entry point that orchestrates the entire flow:
        1. Analyze impact
        2. Check for conflicts
        3. Create GitHub issue
        4. Assign worktree
        5. Generate code
        6. Run tests
        7. Create PR
        8. Auto-merge or flag for review
        """
        try:
            # Step 1: Analyze impact
            affected_entities = self.analyze_impact(change)
            risk_level = self.assess_risk(change, affected_entities)

            # Step 2: Check for conflicts
            conflicts = self.find_conflicts(change)
            if conflicts:
                return self.handle_conflicts(change, conflicts)

            # Step 3: Create GitHub issue
            issue = self.create_issue_for_change(change)
            change.issue_number = issue.number

            # Step 4: Create branch and worktree
            branch_name = f"feature/{issue.number}-{change.target_entity}"
            worktree = self.github.create_worktree(issue.number, branch_name)
            change.worktree = worktree

            # Step 5: Apply the change
            self.apply_change(change)

            # Step 6: Run generators
            self.run_generators(worktree)

            # Step 7: Run tests
            tests_passed = self.run_tests(worktree)

            # Step 8: Commit and push
            commit_message = self.generate_commit_message(change)
            self.github.commit_and_push(commit_message, worktree=worktree)

            # Step 9: Create PR
            pr = self.create_pr_for_change(change, issue, tests_passed)
            change.pr_number = pr.number

            # Step 10: Auto-merge or flag for review
            if self.should_auto_merge(change, risk_level, tests_passed):
                merged = self.github.merge_pr(pr.number)
                if merged:
                    self.github.remove_worktree(worktree)
                    change.status = ChangeStatus.COMPLETED
                    return Result(
                        success=True,
                        status=ChangeStatus.COMPLETED,
                        message=f"Change merged automatically",
                        issue_url=issue.url,
                        pr_url=pr.url
                    )

            change.status = ChangeStatus.NEEDS_REVIEW
            return Result(
                success=True,
                status=ChangeStatus.NEEDS_REVIEW,
                message=f"Change requires review (risk: {risk_level})",
                issue_url=issue.url,
                pr_url=pr.url
            )

        except Exception as e:
            change.status = ChangeStatus.FAILED
            return Result(
                success=False,
                status=ChangeStatus.FAILED,
                message=str(e)
            )

    def analyze_impact(self, change: Change) -> set[str]:
        """Analyze what entities are affected by this change."""
        impact = self.dependency_graph.get_impact(change.target_entity)
        return impact

    def assess_risk(self, change: Change, affected_entities: set[str]) -> str:
        """Assess the risk level of a change."""
        # High risk changes
        if change.type in [
            ChangeType.DELETE_ENTITY,
            ChangeType.MODIFY_WORKFLOW
        ]:
            return "high"

        # Check impact size
        if len(affected_entities) > 3:
            return "high"
        elif len(affected_entities) > 1:
            return "medium"

        # Low risk changes
        if change.type in [
            ChangeType.ADD_PROPERTY,
            ChangeType.ADD_ENTITY
        ]:
            return "low"

        return "medium"

    def find_conflicts(self, change: Change) -> list[Change]:
        """Find conflicts with in-flight changes."""
        conflicts = []
        in_flight_entities = [
            c.target_entity for c in self.active_changes.values()
            if c.status in [ChangeStatus.IN_PROGRESS, ChangeStatus.NEEDS_REVIEW]
        ]

        conflicting_entities = self.dependency_graph.find_conflicts(
            change.target_entity,
            in_flight_entities
        )

        for entity in conflicting_entities:
            for active_change in self.active_changes.values():
                if active_change.target_entity == entity:
                    conflicts.append(active_change)

        return conflicts

    def handle_conflicts(self, change: Change, conflicts: list[Change]) -> Result:
        """Handle conflicts with in-flight changes."""
        # Check if conflicts are close to completion
        close_to_merge = all(
            c.status == ChangeStatus.NEEDS_REVIEW
            for c in conflicts
        )

        if close_to_merge:
            # Queue this change to apply after conflicts merge
            change.status = ChangeStatus.WAITING_FOR_DEPENDENCY
            self.active_changes[change.id] = change
            return Result(
                success=True,
                status=ChangeStatus.WAITING_FOR_DEPENDENCY,
                message=f"Queued - waiting for {len(conflicts)} in-flight changes"
            )

        # Otherwise, flag for manual decision
        return Result(
            success=False,
            status=ChangeStatus.FAILED,
            message=f"Conflict with {len(conflicts)} active changes"
        )

    def create_issue_for_change(self, change: Change) -> Issue:
        """Create a GitHub issue for a change."""
        labels = self.get_labels_for_change(change)

        body = f"""## Change Request

**Type:** {change.type.value}
**Target:** {change.target_entity}
**Requested by:** {change.requested_by}

## Description
{change.description}

## Details
```json
{json.dumps(change.details, indent=2)}
```

## Affected Entities
{', '.join(self.analyze_impact(change))}

---
*Generated by Orchestrator at {datetime.now().isoformat()}*
"""

        return self.github.create_issue(
            title=f"{change.type.value}: {change.description}",
            body=body,
            labels=labels
        )

    def get_labels_for_change(self, change: Change) -> list[str]:
        """Get appropriate labels for a change."""
        labels = ["orchestrator"]

        # Risk-based labels
        risk = self.dependency_graph.analyze_change_risk(change.target_entity)
        labels.append(f"{risk}-risk")

        # Type-based labels
        if "entity" in change.type.value:
            labels.append("entity")
        elif "algorithm" in change.type.value:
            labels.append("algorithm")
        elif "workflow" in change.type.value:
            labels.append("workflow")

        # Auto-merge label for low-risk
        if risk == "low" and change.type in [
            ChangeType.ADD_PROPERTY,
            ChangeType.ADD_ENTITY
        ]:
            labels.append("auto-merge")

        return labels

    def apply_change(self, change: Change):
        """Apply the change to the spec files."""
        # This would modify the appropriate JSON spec file
        # based on the change type and details
        pass  # TODO: Implement spec modification

    def run_generators(self, worktree: Worktree):
        """Run code generators in the worktree."""
        result = subprocess.run(
            ["python", "generators/generate_all.py"],
            cwd=worktree.path,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            raise Exception(f"Generator failed: {result.stderr}")

    def run_tests(self, worktree: Worktree) -> bool:
        """Run tests in the worktree."""
        result = subprocess.run(
            ["pytest", "tests/", "-q"],
            cwd=worktree.path,
            capture_output=True,
            text=True
        )
        return result.returncode == 0

    def generate_commit_message(self, change: Change) -> str:
        """Generate a commit message for a change."""
        prefix = {
            ChangeType.ADD_ENTITY: "feat",
            ChangeType.MODIFY_ENTITY: "refactor",
            ChangeType.DELETE_ENTITY: "refactor",
            ChangeType.ADD_PROPERTY: "feat",
            ChangeType.MODIFY_PROPERTY: "fix",
            ChangeType.ADD_ALGORITHM: "feat",
            ChangeType.MODIFY_ALGORITHM: "fix",
            ChangeType.ADD_WORKFLOW: "feat",
            ChangeType.MODIFY_WORKFLOW: "refactor",
        }.get(change.type, "chore")

        return f"""{prefix}({change.target_entity}): {change.description}

Closes #{change.issue_number}

Generated by Orchestrator
"""

    def create_pr_for_change(
        self,
        change: Change,
        issue: Issue,
        tests_passed: bool
    ) -> PullRequest:
        """Create a PR for a change."""
        body = f"""## Summary
{change.description}

Closes #{issue.number}

## Test Results
{"✅ All tests passing" if tests_passed else "⚠️ Some tests failing"}

## Affected Entities
{', '.join(self.analyze_impact(change))}

---
*Generated by Orchestrator*
"""

        labels = self.get_labels_for_change(change)
        if tests_passed:
            labels.append("tests-passing")

        return self.github.create_pr(
            title=f"{change.type.value}: {change.description}",
            body=body,
            head_branch=change.worktree.branch,
            labels=labels
        )

    def should_auto_merge(
        self,
        change: Change,
        risk_level: str,
        tests_passed: bool
    ) -> bool:
        """Determine if a change should be auto-merged."""
        if not tests_passed:
            return False

        if risk_level == "high":
            return False

        if change.type in [
            ChangeType.DELETE_ENTITY,
            ChangeType.MODIFY_WORKFLOW
        ]:
            return False

        return risk_level == "low"

    def get_status(self) -> dict:
        """Get current orchestrator status."""
        return {
            "active_changes": len(self.active_changes),
            "by_status": {
                status.value: len([
                    c for c in self.active_changes.values()
                    if c.status == status
                ])
                for status in ChangeStatus
            },
            "worktrees": len(self.github.list_worktrees()),
            "open_prs": len(self.github.list_open_prs())
        }
