#!/bin/bash
#
# Pre-commit hook: Enforces the model-driven workflow
#
# Checks:
# 1. JSON specs are valid against schema
# 2. Generated code matches specs (no manual edits to generated files)
# 3. Tests pass
# 4. Coverage meets threshold
#
# Install: git config core.hooksPath .githooks

set -e

echo "üîç Running pre-commit checks..."

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Track if any check fails
FAILED=0

# ============================================
# Check 0: Verify GitHub issue exists (Issue-First Workflow)
# ============================================
echo -n "  Checking for GitHub issue reference... "

# Get current branch name
BRANCH_NAME=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

# Check if branch follows issue pattern: issue-<number>-* or feature/<number>-*
ISSUE_BRANCH_PATTERN="^(issue|feature|fix|bugfix)-([0-9]+)"
ISSUE_NUMBER=""

if [[ "$BRANCH_NAME" =~ $ISSUE_BRANCH_PATTERN ]]; then
    ISSUE_NUMBER="${BASH_REMATCH[2]}"
    echo -e "${GREEN}OK${NC} (branch references issue #$ISSUE_NUMBER)"
elif [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "develop" ]]; then
    # On main branches, check commit message for issue reference
    # This will be validated in prepare-commit-msg or commit-msg hook
    echo -e "${YELLOW}WARNING${NC} (on $BRANCH_NAME - commit msg must reference issue)"
    echo -e "    ${YELLOW}‚Üí Use: git commit -m 'Your message #123' or 'fixes #123'${NC}"
else
    echo -e "${RED}FAILED${NC}"
    echo "    ‚ùå Branch name must reference a GitHub issue"
    echo "    ${YELLOW}‚Üí Create an issue first: gh issue create${NC}"
    echo "    ${YELLOW}‚Üí Then create branch: git checkout -b issue-<number>-description${NC}"
    echo ""
    echo "    Valid branch patterns:"
    echo "      - issue-123-add-feature"
    echo "      - feature-456-new-module"
    echo "      - fix-789-bug-description"
    echo "      - bugfix-101-error-handling"
    FAILED=1
fi

# ============================================
# Check 1: Validate JSON specs against schema
# ============================================
echo -n "  Validating JSON specs... "

if [ -d "specs" ]; then
    # Check if jsonschema is installed
    if command -v python3 &> /dev/null; then
        python3 << 'EOF'
import json
import sys
from pathlib import Path

try:
    from jsonschema import validate, ValidationError
except ImportError:
    print("‚ö†Ô∏è  jsonschema not installed, skipping validation")
    sys.exit(0)

specs_dir = Path("specs")
schema_dir = specs_dir / "schema"

validations = [
    ("entities.json", "entity.schema.json"),
    ("algorithms.json", "algorithm.schema.json"),
    ("workflows.json", "workflow.schema.json"),
    ("roles.json", "roles.schema.json"),
]

errors = []
for spec_file, schema_file in validations:
    spec_path = specs_dir / spec_file
    schema_path = schema_dir / schema_file

    if spec_path.exists() and schema_path.exists():
        try:
            with open(spec_path) as f:
                spec = json.load(f)
            with open(schema_path) as f:
                schema = json.load(f)
            validate(instance=spec, schema=schema)
        except ValidationError as e:
            errors.append(f"{spec_file}: {e.message}")
        except json.JSONDecodeError as e:
            errors.append(f"{spec_file}: Invalid JSON - {e}")

if errors:
    print("FAILED")
    for error in errors:
        print(f"    ‚ùå {error}")
    sys.exit(1)
else:
    print("OK")
EOF
        if [ $? -ne 0 ]; then
            FAILED=1
        fi
    else
        echo -e "${YELLOW}SKIPPED${NC} (python3 not found)"
    fi
else
    echo -e "${YELLOW}SKIPPED${NC} (no specs directory)"
fi

# ============================================
# Check 2: Verify generated code not manually edited
# ============================================
echo -n "  Checking for manual edits to generated code... "

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Generated directories that should not be manually edited
GENERATED_PATTERNS=(
    "src/domain/models/"
    "src/app/api/generated/"
)

MANUAL_EDITS=()
for file in $STAGED_FILES; do
    for pattern in "${GENERATED_PATTERNS[@]}"; do
        if [[ "$file" == $pattern* ]]; then
            # Check if corresponding spec was also modified
            SPEC_MODIFIED=0
            if git diff --cached --name-only | grep -q "specs/"; then
                SPEC_MODIFIED=1
            fi

            if [ $SPEC_MODIFIED -eq 0 ]; then
                MANUAL_EDITS+=("$file")
            fi
        fi
    done
done

if [ ${#MANUAL_EDITS[@]} -gt 0 ]; then
    echo -e "${RED}FAILED${NC}"
    echo -e "    ${RED}‚ùå Manual edits detected in generated files:${NC}"
    for file in "${MANUAL_EDITS[@]}"; do
        echo "       - $file"
    done
    echo -e "    ${YELLOW}‚Üí Edit specs/ and run /generate instead${NC}"
    FAILED=1
else
    echo -e "${GREEN}OK${NC}"
fi

# ============================================
# Check 3: Run tests (MANDATORY)
# ============================================
echo -n "  Running tests... "

if [ ! -d "tests" ]; then
    echo -e "${RED}FAILED${NC}"
    echo "    ‚ùå No tests directory found"
    echo "    ${YELLOW}‚Üí Tests are mandatory. Create tests/ directory with test files${NC}"
    FAILED=1
elif ! command -v pytest &> /dev/null; then
    echo -e "${RED}FAILED${NC}"
    echo "    ‚ùå pytest not found"
    echo "    ${YELLOW}‚Üí Install: pip install pytest pytest-cov${NC}"
    FAILED=1
else
    # Run tests with coverage check
    if pytest tests/ -q --tb=short --cov=src --cov-fail-under=80 > /tmp/pytest_output.txt 2>&1; then
        echo -e "${GREEN}OK${NC}"
        # Show coverage summary
        grep -E "^TOTAL|^Name" /tmp/pytest_output.txt | tail -2
    else
        echo -e "${RED}FAILED${NC}"
        echo "    ‚ùå Tests failed or coverage below 80%:"
        cat /tmp/pytest_output.txt | tail -30
        FAILED=1
    fi
fi

# ============================================
# Check 4: Lint TypeScript/JavaScript
# ============================================
echo -n "  Linting code... "

if [ -f "package.json" ] && command -v npx &> /dev/null; then
    # Check if eslint is configured
    if [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f "eslint.config.mjs" ]; then
        # Only lint staged files
        STAGED_JS=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx|js|jsx)$' || true)
        if [ -n "$STAGED_JS" ]; then
            if npx eslint $STAGED_JS --quiet > /tmp/eslint_output.txt 2>&1; then
                echo -e "${GREEN}OK${NC}"
            else
                echo -e "${RED}FAILED${NC}"
                cat /tmp/eslint_output.txt | head -20
                FAILED=1
            fi
        else
            echo -e "${GREEN}OK${NC} (no JS/TS files staged)"
        fi
    else
        echo -e "${YELLOW}SKIPPED${NC} (no eslint config)"
    fi
else
    echo -e "${YELLOW}SKIPPED${NC} (no package.json)"
fi

# ============================================
# Check 5: Python type checking
# ============================================
echo -n "  Type checking Python... "

STAGED_PY=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)
if [ -n "$STAGED_PY" ] && command -v mypy &> /dev/null; then
    if mypy $STAGED_PY --ignore-missing-imports --no-error-summary > /tmp/mypy_output.txt 2>&1; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${YELLOW}WARNINGS${NC}"
        # Don't fail on mypy warnings, just show them
        cat /tmp/mypy_output.txt | head -10
    fi
elif [ -n "$STAGED_PY" ]; then
    echo -e "${YELLOW}SKIPPED${NC} (mypy not found)"
else
    echo -e "${GREEN}OK${NC} (no Python files staged)"
fi

# ============================================
# Final result
# ============================================
echo ""
if [ $FAILED -eq 1 ]; then
    echo -e "${RED}‚ùå Pre-commit checks failed. Please fix the issues above.${NC}"
    echo -e "${YELLOW}   Use 'git commit --no-verify' to bypass (not recommended)${NC}"
    exit 1
else
    echo -e "${GREEN}‚úÖ All pre-commit checks passed!${NC}"
    exit 0
fi
